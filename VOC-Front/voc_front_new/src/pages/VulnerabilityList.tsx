import React, { useState, useEffect, useMemo } from 'react';
import { useNavigate } from 'react-router-dom';
import { Vulnerability } from '../types';
import VulnerabilityTable from '../components/dashboard/VulnerabilityTable';
import { Filter, Download, RefreshCw, AlertTriangle, Loader, ChevronLeft, ChevronRight } from 'lucide-react';
import { fetchVulnerabilities } from '../utils/api';
import ApiErrorMessage from '../components/common/ApiErrorMessage';
import { calculateRiskScore, isHighRisk } from '../utils/helpers';

interface VulnerabilityListProps {
  filterType?: 'all' | 'critical' | 'recent' | 'high-risk' | 'with-exploit';
}

const VulnerabilityList: React.FC<VulnerabilityListProps> = ({ filterType = 'all' }) => {
  const [vulnerabilities, setVulnerabilities] = useState<Vulnerability[]>([]);
  const [filteredVulnerabilities, setFilteredVulnerabilities] = useState<Vulnerability[]>([]);
  const [loading, setLoading] = useState(true);
  const [initialLoading, setInitialLoading] = useState(true); // État pour le chargement initial
  const [error, setError] = useState<string | null>(null);
  
  // Filter states
  const [searchTerm, setSearchTerm] = useState('');
  const [severityFilter, setSeverityFilter] = useState<string>(filterType === 'critical' ? 'CRITICAL' : 'all');
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [vendorFilter, setVendorFilter] = useState<string>('all');
  const [productFilter, setProductFilter] = useState<string>('all');
  const [cvssMinFilter, setCvssMinFilter] = useState<string>('');
  const [cvssMaxFilter, setCvssMaxFilter] = useState<string>('');
  const [epssMinFilter, setEpssMinFilter] = useState<string>('');
  const [epssMaxFilter, setEpssMaxFilter] = useState<string>('');
  const [kevFilter, setKevFilter] = useState<string>('all');
  const [hasExploitFilter, setHasExploitFilter] = useState<string>('all');
  const [dateFromFilter, setDateFromFilter] = useState<string>(filterType === 'recent' ? getLastMonthDate() : '');
  const [dateToFilter, setDateToFilter] = useState<string>('');
  const [showFilters, setShowFilters] = useState(false);
  
  // Nouveaux états pour la pagination
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage, setItemsPerPage] = useState(20);
  const [paginatedVulnerabilities, setPaginatedVulnerabilities] = useState<Vulnerability[]>([]);

  const navigate = useNavigate(); // Hook pour la navigation

  // États pour le tri
  const [sortField, setSortField] = useState<keyof Vulnerability>('cve_id');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');

  // Fonction pour afficher les détails de la vulnérabilité et naviguer
  const handleViewDetails = (vulnerability: Vulnerability) => {
    navigate(`/vi/vulnerabilities/${vulnerability.cve_id}`, { state: { vulnerability } });
  };

  // Fonction pour obtenir la date d'il y a un mois
  function getLastMonthDate() {
    const date = new Date();
    date.setMonth(date.getMonth() - 1);
    return date.toISOString().split('T')[0];
  }

  useEffect(() => {
    fetchData();
  }, []);

  useEffect(() => {
    // Mettre à jour les filtres en fonction du type de page
    if (filterType === 'critical') {
      setSeverityFilter('CRITICAL');
    } else if (filterType === 'recent') {
      setDateFromFilter(getLastMonthDate());
    }
  }, [filterType]);

  // Add the applyFilters function
  const applyFilters = () => {
    // Call fetchData with current filters
    fetchData();
  };

  // Modifier le useMemo pour éviter la référence circulaire
  useEffect(() => {
    if (!loading && vulnerabilities.length > 0) {
      // Appliquer les filtres localement au lieu d'appeler fetchData
      let filtered = [...vulnerabilities];
      
      // Appliquer les filtres côté client
      if (searchTerm) {
        const searchLower = searchTerm.toLowerCase();
        filtered = filtered.filter(v => 
          v.cve_id.toLowerCase().includes(searchLower) ||
          (v.title && v.title.toLowerCase().includes(searchLower)) ||
          (v.description && v.description.toLowerCase().includes(searchLower))
        );
      }
      
      // Filtrer par sévérité si nécessaire
      if (severityFilter !== 'all') {
        filtered = filtered.filter(v => v.severity === severityFilter);
      }
      
      // Filtrer par statut si nécessaire
      if (statusFilter !== 'all') {
        filtered = filtered.filter(v => v.status === statusFilter);
      }
      
      // Filtrer par vendor si nécessaire
      if (vendorFilter !== 'all') {
        filtered = filtered.filter(v => v.vendor === vendorFilter);
      }
      
      // Filtrer par product si nécessaire
      if (productFilter !== 'all') {
        filtered = filtered.filter(v => v.product === productFilter);
      }
      
      // Filtrer par score CVSS
      if (cvssMinFilter) {
        const min = parseFloat(cvssMinFilter);
        filtered = filtered.filter(v => v.cvss_score >= min);
      }
      
      if (cvssMaxFilter) {
        const max = parseFloat(cvssMaxFilter);
        filtered = filtered.filter(v => v.cvss_score <= max);
      }
      
      // Filtrer par score EPSS
      if (epssMinFilter && typeof epssMinFilter === 'string') {
        const min = parseFloat(epssMinFilter);
        filtered = filtered.filter(v => v.epss_score !== undefined && v.epss_score >= min);
      }
      
      if (epssMaxFilter && typeof epssMaxFilter === 'string') {
        const max = parseFloat(epssMaxFilter);
        filtered = filtered.filter(v => v.epss_score !== undefined && v.epss_score <= max);
      }
      
      // Filtrer par KEV
      if (kevFilter !== 'all') {
        filtered = filtered.filter(v => v.is_kev === (kevFilter === 'yes'));
      }
      
      // Filtrer par disponibilité d'exploit
      if (hasExploitFilter !== 'all') {
        filtered = filtered.filter(v => v.has_poc === (hasExploitFilter === 'yes'));
      }
      
      // Filtrer par date
      if (dateFromFilter) {
        const fromDate = new Date(dateFromFilter);
        filtered = filtered.filter(v => new Date(v.published_date) >= fromDate);
      }
      
      if (dateToFilter) {
        const toDate = new Date(dateToFilter);
        toDate.setHours(23, 59, 59, 999); // Fin de la journée
        filtered = filtered.filter(v => new Date(v.published_date) <= toDate);
      }
      
      // Apply high-risk filter if on high-risk page
      if (filterType === 'high-risk') {
        filtered = filtered.filter(v => isHighRisk(v));
      }
      
      // Apply with-exploit filter if on with-exploit page
      if (filterType === 'with-exploit') {
        filtered = filtered.filter(v => v.has_poc === true);
      }
      
      setFilteredVulnerabilities(filtered);
    }
  }, [
    vulnerabilities,
    searchTerm,
    severityFilter,
    statusFilter,
    vendorFilter,
    productFilter,
    cvssMinFilter,
    cvssMaxFilter,
    epssMinFilter,
    epssMaxFilter,
    kevFilter,
    hasExploitFilter,
    dateFromFilter,
    dateToFilter,
    filterType,
    loading
  ]);

  // Appliquer le tri après le filtrage
  const sortedAndFilteredVulnerabilities = useMemo(() => {
    const sortableVulnerabilities = [...filteredVulnerabilities];
    if (sortField) {
      sortableVulnerabilities.sort((a, b) => {
        const fieldA = a[sortField];
        const fieldB = b[sortField];

        if (sortField === 'published_date') {
          const dateA = new Date(fieldA as string);
          const dateB = new Date(fieldB as string);
          if (dateA < dateB) return sortDirection === 'asc' ? -1 : 1;
          if (dateA > dateB) return sortDirection === 'asc' ? 1 : -1;
          return 0;
        } else if (sortField === 'cve_id') {
          // Custom sorting for CVE IDs to handle years correctly
          const getYearFromCveId = (cveId: string) => {
            const match = cveId.match(/CVE-(\d{4})-\d+/);
            return match ? parseInt(match[1]) : 0;
          };

          const yearA = getYearFromCveId(a.cve_id);
          const yearB = getYearFromCveId(b.cve_id);

          if (yearA < yearB) return sortDirection === 'asc' ? -1 : 1;
          if (yearA > yearB) return sortDirection === 'asc' ? 1 : -1;

          // If years are the same, sort by full CVE ID string
          if (a.cve_id < b.cve_id) return sortDirection === 'asc' ? -1 : 1;
          if (a.cve_id > b.cve_id) return sortDirection === 'asc' ? 1 : -1;
          return 0;
        } else {
          // Generic comparison for other fields (strings and numbers)
          if (fieldA === undefined || fieldA === null) return sortDirection === 'asc' ? 1 : -1;
          if (fieldB === undefined || fieldB === null) return sortDirection === 'asc' ? -1 : 1;

          if (fieldA < fieldB) return sortDirection === 'asc' ? -1 : 1;
          if (fieldA > fieldB) return sortDirection === 'asc' ? 1 : -1;
          return 0;
        }
      });
    }
    return sortableVulnerabilities;
  }, [filteredVulnerabilities, sortField, sortDirection]);

  // Effet pour mettre à jour les éléments paginés lorsque les filtres ou la page changent
  useEffect(() => {
    updatePaginatedItems();
  }, [sortedAndFilteredVulnerabilities, currentPage, itemsPerPage]);

  const updatePaginatedItems = () => {
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    setPaginatedVulnerabilities(sortedAndFilteredVulnerabilities.slice(startIndex, endIndex));
  };

  const fetchData = async () => {
    setLoading(true);
    setInitialLoading(true);
    setError(null);
    try {
      console.log(`Fetching vulnerabilities for ${filterType} page...`);
      
      // Préparer les filtres en fonction du type de page
      const filters: any = {
        severity: severityFilter !== 'all' ? severityFilter : undefined,
        status: statusFilter !== 'all' ? statusFilter : undefined,
        vendor: vendorFilter !== 'all' ? vendorFilter : undefined,
        product: productFilter !== 'all' ? productFilter : undefined,
        kev: kevFilter !== 'all' ? (kevFilter === 'yes' ? 'yes' : 'no') : undefined,
        has_poc: hasExploitFilter !== 'all' ? (hasExploitFilter === 'yes' ? 'yes' : 'no') : undefined,
        cvss_min: cvssMinFilter ? parseFloat(cvssMinFilter) : undefined,
        cvss_max: cvssMaxFilter ? parseFloat(cvssMaxFilter) : undefined,
        epss_min: epssMinFilter ? parseFloat(epssMinFilter) : undefined,
        epss_max: epssMaxFilter ? parseFloat(epssMaxFilter) : undefined,
        search: 'CVE-2025', // Forcer le filtre côté frontend
      };
      
      // Appliquer les filtres spécifiques au type de page
      if (filterType === 'critical') {
        filters.severity = 'CRITICAL';
        console.log('Setting severity filter to CRITICAL for critical page');
      } else if (filterType === 'recent') {
        // Pour les récentes, on garde le filtre de date côté client
      } else if (filterType === 'with-exploit') {
        // Définir explicitement le filtre has_poc à 'yes' pour les vulnérabilités avec exploit
        filters.has_poc = 'yes';
        console.log('Setting has_poc filter to yes for with-exploit page');
      }
      
      console.log('Applying filters:', JSON.stringify(filters));
      
      // Récupérer les vulnérabilités avec les filtres appliqués
      const response = await fetchVulnerabilities(filters);
      
      console.log(`Received ${response.data.length} vulnerabilities after filtering`);
      
      if (response.data.length === 0) {
        console.warn("No vulnerabilities received from API");
        if (filterType === 'with-exploit') {
          setError("Aucune vulnérabilité avec exploit n'a été trouvée. Il est possible que les données ne soient pas disponibles ou que le champ 'has_poc' ne soit pas correctement défini dans les données.");
        } else {
          setError("Aucune vulnérabilité n'a été trouvée. Veuillez vérifier la connexion à l'API.");
        }
      } else {
        // Analyser les données reçues
        const criticalCount = response.data.filter(v => v.severity === 'CRITICAL').length;
        const highCount = response.data.filter(v => v.severity === 'HIGH').length;
        const mediumCount = response.data.filter(v => v.severity === 'MEDIUM').length;
        const lowCount = response.data.filter(v => v.severity === 'LOW').length;
        const exploitCount = response.data.filter(v => v.has_poc === true).length;
        
        console.log(`Breakdown by severity: Critical=${criticalCount}, High=${highCount}, Medium=${mediumCount}, Low=${lowCount}`);
        console.log(`Total vulnerabilities with exploit: ${exploitCount}`);
        
        setVulnerabilities(response.data);
        setFilteredVulnerabilities(response.data);
        
        // Réinitialiser à la première page
        setCurrentPage(1);
      }
    } catch (error) {
      console.error('Erreur de chargement des vulnérabilités :', error);
      setError(`Erreur lors du chargement des données: ${error}`);
    } finally {
      setLoading(false);
      // Attendre un peu avant de masquer l'indicateur de chargement initial
      setTimeout(() => {
        setInitialLoading(false);
      }, 500);
    }
  };

  const handleExport = () => {
    const csvContent = 
      'CVE ID,Title,Severity,CVSS Score,EPSS Score,Status,Vendor,Product,Published Date,Is KEV,Has PoC\n' +
      filteredVulnerabilities.map(v => 
        `${v.cve_id},"${v.title?.replace(/"/g, '""') || ''}",${v.severity},${v.cvss_score},${v.epss_score || ''},${v.status},${v.vendor || ''},${v.product || ''},${v.published_date},${v.is_kev},${v.has_poc || false}`
      ).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', 'vulnerabilities.csv');
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const getUniqueValues = (field: keyof Vulnerability) => {
    const values = vulnerabilities.map(v => v[field]);
    return ['all', ...new Set(values.filter(Boolean))]; // Filtrer les valeurs null/undefined
  };

  const toggleFilters = () => {
    setShowFilters(!showFilters);
  };

  const clearFilters = () => {
    setSearchTerm('');
    setSeverityFilter(filterType === 'critical' ? 'CRITICAL' : 'all');
    setStatusFilter('all');
    setVendorFilter('all');
    setProductFilter('all');
    setCvssMinFilter('');
    setCvssMaxFilter('');
    setEpssMinFilter('');
    setEpssMaxFilter('');
    setKevFilter('all');
    setHasExploitFilter('all');
    setDateFromFilter(filterType === 'recent' ? getLastMonthDate() : '');
    setDateToFilter('');
  };

  // Fonctions de pagination
  const totalPages = Math.ceil(filteredVulnerabilities.length / itemsPerPage);
  
  const goToNextPage = () => {
    if (currentPage < totalPages) {
      setCurrentPage(currentPage + 1);
    }
  };
  
  const goToPreviousPage = () => {
    if (currentPage > 1) {
      setCurrentPage(currentPage - 1);
    }
  };
  
  const goToPage = (page: number) => {
    if (page >= 1 && page <= totalPages) {
      setCurrentPage(page);
    }
  };

  // Titre de la page en fonction du type de filtre
  const getPageTitle = () => {
    switch (filterType) {
      case 'critical':
        return 'Vulnérabilités Critiques';
      case 'recent':
        return 'Vulnérabilités Récentes';
      case 'high-risk':
        return 'Vulnérabilités à Haut Risque';
      case 'with-exploit':
        return 'Vulnérabilités avec Exploit';
      default:
        return 'Liste des Vulnérabilités';
    }
  };

  if (initialLoading) {
    return (
      <div className="flex flex-col justify-center items-center h-[calc(100vh-4rem)]">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary-500 mb-4"></div>
        <p className="text-gray-500 dark:text-gray-400">Chargement des vulnérabilités...</p>
        <p className="text-sm text-gray-400 dark:text-gray-500 mt-2">Cela peut prendre quelques instants</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex flex-col justify-center items-center h-[calc(100vh-4rem)]">
        <div className="text-red-500 mb-4">
          <AlertTriangle className="h-12 w-12" />
        </div>
        <h2 className="text-xl font-semibold mb-2">Erreur</h2>
        <p className="text-gray-500 dark:text-gray-400">{error}</p>
        <button 
          onClick={fetchData}
          className="mt-4 px-4 py-2 bg-primary-500 text-white rounded-md hover:bg-primary-600"
        >
          <RefreshCw className="h-4 w-4 mr-1 inline" />
          Réessayer
        </button>
      </div>
    );
  }

  return (
    <div className="container mx-auto px-4 py-6">
      <h1 className="text-2xl font-bold mb-6">
        {filterType === 'critical' ? 'Vulnérabilités Critiques' : 
         filterType === 'recent' ? 'Vulnérabilités Récentes' : 
         filterType === 'high-risk' ? 'Vulnérabilités à Haut Risque' : 
         filterType === 'with-exploit' ? 'Vulnérabilités avec Exploit' :
         'Toutes les Vulnérabilités'}
      </h1>
      
      {/* Afficher le message d'erreur si nécessaire */}
      {error && (
        <ApiErrorMessage 
          message={error} 
          onRetry={fetchData} 
        />
      )}
      
      {/* Header with actions */}
      <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
        <h2 className="text-xl font-semibold">
          {getPageTitle()} ({filteredVulnerabilities.length})
          {loading && <Loader className="h-4 w-4 ml-2 inline animate-spin" />}
        </h2>
        <div className="flex flex-wrap items-center gap-2">
          <button 
            onClick={toggleFilters}
            className="btn-secondary flex items-center text-sm"
          >
            <Filter className="h-4 w-4 mr-1" />
            Filtres avancés
          </button>
          <button 
            onClick={handleExport}
            className="btn-secondary flex items-center text-sm"
          >
            <Download className="h-4 w-4 mr-1" />
            Exporter CSV
          </button>
          <button 
            onClick={fetchData}
            className="btn-primary flex items-center text-sm"
            disabled={loading}
          >
            <RefreshCw className={`h-4 w-4 mr-1 ${loading ? 'animate-spin' : ''}`} />
            Actualiser
          </button>
        </div>
      </div>

      {/* Search and filters */}
      <div className={`${showFilters ? 'block' : 'hidden'} card p-4 animate-fade-in`}>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
          {/* Basic filters */}
          <div>
            <label htmlFor="search" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Recherche globale
            </label>
            <input
              type="text"
              id="search"
              className="w-full rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
              placeholder="CVE, titre, description..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </div>

          <div>
            <label htmlFor="severity" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Sévérité
            </label>
            <select
              id="severity"
              className="w-full rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
              value={severityFilter}
              onChange={(e) => setSeverityFilter(e.target.value)}
            >
              <option value="all">Toutes</option>
              <option value="CRITICAL">Critique</option>
              <option value="HIGH">Élevée</option>
              <option value="MEDIUM">Moyenne</option>
              <option value="LOW">Faible</option>
            </select>
          </div>

          <div>
            <label htmlFor="status" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Statut
            </label>
            <select
              id="status"
              className="w-full rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
              value={statusFilter}
              onChange={(e) => setStatusFilter(e.target.value)}
            >
              <option value="all">Tous</option>
              <option value="OPEN">Ouvert</option>
              <option value="CLOSED">Fermé</option>
              <option value="IN_PROGRESS">En cours</option>
            </select>
          </div>

          <div>
            <label htmlFor="vendor" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Vendor
            </label>
            <select
              id="vendor"
              className="w-full rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
              value={vendorFilter}
              onChange={(e) => setVendorFilter(e.target.value)}
            >
              <option value="all">Tous</option>
              {getUniqueValues('vendor').filter(v => v !== 'all').map(vendor => (
                <option key={vendor} value={vendor}>{vendor}</option>
              ))}
            </select>
          </div>

          {/* Advanced filters */}
          <div>
            <label htmlFor="product" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Produit
            </label>
            <select
              id="product"
              className="w-full rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
              value={productFilter}
              onChange={(e) => setProductFilter(e.target.value)}
            >
              <option value="all">Tous</option>
              {getUniqueValues('product').filter(v => v !== 'all').map(product => (
                <option key={product} value={product}>{product}</option>
              ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Score CVSS
            </label>
            <div className="flex space-x-2">
              <input
                type="number"
                placeholder="Min"
                min="0"
                max="10"
                step="0.1"
                className="w-1/2 rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                value={cvssMinFilter}
                onChange={(e) => setCvssMinFilter(e.target.value)}
              />
              <input
                type="number"
                placeholder="Max"
                min="0"
                max="10"
                step="0.1"
                className="w-1/2 rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                value={cvssMaxFilter}
                onChange={(e) => setCvssMaxFilter(e.target.value)}
              />
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Score EPSS
            </label>
            <div className="flex space-x-2">
              <input
                type="number"
                placeholder="Min"
                min="0"
                max="1"
                step="0.01"
                className="w-1/2 rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                value={epssMinFilter}
                onChange={(e) => setEpssMinFilter(e.target.value)}
              />
              <input
                type="number"
                placeholder="Max"
                min="0"
                max="1"
                step="0.01"
                className="w-1/2 rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                value={epssMaxFilter}
                onChange={(e) => setEpssMaxFilter(e.target.value)}
              />
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Date de publication
            </label>
            <div className="flex space-x-2">
              <input
                type="date"
                className="w-1/2 rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                value={dateFromFilter}
                onChange={(e) => setDateFromFilter(e.target.value)}
              />
              <input
                type="date"
                className="w-1/2 rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
                value={dateToFilter}
                onChange={(e) => setDateToFilter(e.target.value)}
              />
            </div>
          </div>

          <div>
            <label htmlFor="kev" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Known Exploited Vulnerability
            </label>
            <select
              id="kev"
              className="w-full rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
              value={kevFilter}
              onChange={(e) => setKevFilter(e.target.value)}
            >
              <option value="all">Tous</option>
              <option value="yes">Oui</option>
              <option value="no">Non</option>
            </select>
          </div>

          <div>
            <label htmlFor="hasExploit" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Exploit disponible
            </label>
            <select
              id="hasExploit"
              className="w-full rounded-md border-gray-300 dark:border-dark-300 bg-white dark:bg-dark-200 text-gray-900 dark:text-gray-100 shadow-sm focus:border-primary-500 focus:ring-primary-500"
              value={hasExploitFilter}
              onChange={(e) => setHasExploitFilter(e.target.value)}
            >
              <option value="all">Tous</option>
              <option value="yes">Oui</option>
              <option value="no">Non</option>
            </select>
          </div>
        </div>

        {/* Boutons d'action pour les filtres */}
        <div className="flex justify-end mt-4 gap-2">
          <button
            onClick={clearFilters}
            className="btn-secondary text-sm"
          >
            Réinitialiser les filtres
          </button>
          <button
            onClick={applyFilters}
            className="btn-primary text-sm"
            disabled={loading}
          >
            Appliquer les filtres
            {loading && <span className="ml-2 animate-spin">⟳</span>}
          </button>
        </div>
      </div>

      {/* Results summary */}
      <div className="flex justify-between items-center">
        <p className="text-sm text-gray-500 dark:text-gray-400">
          {filteredVulnerabilities.length} résultat{filteredVulnerabilities.length !== 1 ? 's' : ''}
        </p>
      </div>

      {/* Table */}
      {filteredVulnerabilities.length > 0 ? (
        <>
          <div className="mb-6">
            <VulnerabilityTable 
              vulnerabilities={paginatedVulnerabilities} 
              onViewDetails={handleViewDetails}
            />
          </div>
          <div className="flex justify-center items-center mt-4">
            <button
              onClick={goToPreviousPage}
              className={`btn-secondary ${currentPage === 1 ? 'opacity-50 cursor-not-allowed' : ''}`}
              disabled={currentPage === 1}
            >
              <ChevronLeft className="h-4 w-4" />
            </button>
            <div className="mx-4">
              Page {currentPage} sur {totalPages}
            </div>
            <button
              onClick={goToNextPage}
              className={`btn-secondary ${currentPage === totalPages ? 'opacity-50 cursor-not-allowed' : ''}`}
              disabled={currentPage === totalPages}
            >
              <ChevronRight className="h-4 w-4" />
            </button>
          </div>
        </>
      ) : (
        <div className="bg-white dark:bg-dark-200 rounded-lg shadow-sm overflow-hidden border border-gray-200 dark:border-dark-300 p-6 text-center text-gray-500 dark:text-gray-400">
          <p>Aucune vulnérabilité trouvée pour les filtres sélectionnés.</p>
        </div>
      )}
    </div>
  );
};

export default VulnerabilityList;
